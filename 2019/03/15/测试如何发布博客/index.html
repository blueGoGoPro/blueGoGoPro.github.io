<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 测试如何发布博客 · 开弓</title><meta name="description" content="测试如何发布博客 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico?v=2018"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="开弓"></head><body><div class="wrap"><header><h1 class="title">Jeremy's Blog</h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="http://jeremyfan.name" target="_blank">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">测试如何发布博客</h1><div class="post-info">Mar 15, 2019</div><div class="post-content"><p>avaScript 中的数值类型用起来很简单，但内部如何存储却是有点复杂。我们在使用的过程也偶尔会遇到一些问题，比如为什么整数被截断了，为什么小数计算不精准了。</p>
<p>这篇文章就主要来讨论这些问题，具体来说，在 JavaScript 中：</p>
<ol>
<li>数值是如何存储的？</li>
<li>为什么能够精确表示的整数范围是 -9007199254740991~9007199254740991？</li>
<li>为什么能够表示的最大数值范围是 5e-324~1.7976931348623157e+308？</li>
<li>为什么 0.1+0.2 不等于 0.3？</li>
</ol>
<blockquote>
<p>avaScript 中的数值类型用起来很简单，但内部如何存储却是有点复杂。我们在使用的过程也偶尔会遇到一些问题，比如为什么整数被截断了，为什么小数计算不精准了。</p>
<p>这篇文章就主要来讨论这些问题，具体来说，在 JavaScript 中：</p>
<ol>
<li>数值是如何存储的？</li>
<li>为什么能够精确表示的整数范围是 <code>-9007199254740991~9007199254740991</code>？</li>
<li>为什么能够表示的最大数值范围是 <code>5e-324~1.7976931348623157e+308</code>？</li>
<li>为什么 0.1+0.2 不等于 0.3？</li>
</ol>
<h2 id="一、数值的存储"><a href="#一、数值的存储" class="headerlink" title="一、数值的存储"></a>一、数值的存储</h2><p>提到 JavaScript 的数值存储，就不能不提 IEEE754 标准，因为 JavaScript 就是以 IEEE754 标准的双精度浮点数存储数值的。</p>
<p>按照 IEEE754 标准，计算机中的数值都以二进制科学计数法表示，也就是 <code>1.0101 * 2e+5</code> 这种（随便写的一个数），可以认为一个数值是由<strong>符号（sign）</strong>、<strong>指数部分（exponent）</strong>、<strong>小数部分（fraction）</strong>三块组成。</p>
<p><img src="https://raw.githubusercontent.com/JeremyFan/static/images/blogs/ieee754-64.png" alt="img"></p>
<p>那么这三部分具体是如何存储的呢？在 IEEE754 的双精度浮点数规范中，计算机会使用 8 个字节共 64 位表示一个数值，相应的分成三个部分：</p>
<ul>
<li>最高位是符号位</li>
<li>第 2~12 位是指数位</li>
<li>第 13~64 位是小数位</li>
</ul>
<p>下面分别来说明这三个部分。</p>
<h3 id="符号位（sign）"><a href="#符号位（sign）" class="headerlink" title="符号位（sign）"></a>符号位（sign）</h3><p>这个比较好理解，专门一个 bit 表示数值的正负，当符号位为 0 时，表示正数；当符号位为 1 时，表示负数。</p>
<h3 id="指数位（exponent）"><a href="#指数位（exponent）" class="headerlink" title="指数位（exponent）"></a>指数位（exponent）</h3><p>指数位共有 11 位，可表示的最小值是 0，最大值是 2047（即 <code>2e11-1</code>）。指数也有正负，指数的正负并没有使用符号位表示，而是使用了偏移量的设计，对于双精度浮点数来说偏移量是 1023，也就是说真实指数值会加上 1023 后存储。比如 -2 存储为 1021，0 存储为 1023，10 存储为 1033。所以指数位存储的值是 <code>0~2047</code>，实际指数值的范围是 <code>-1023~1024</code>。</p>
<p>但 -1023 和 1024 作为边界情况，要去表示特殊值，简单的说就是：</p>
<ul>
<li>如果指数位是 -1023，而小数位是 0，那么就表示数字 0，加上符号位就是 +-0；</li>
<li>如果指数位是 1024，分两种情况：<ul>
<li>小数位是 0，表示 <code>Infinity</code>，加上符号位就是 <code>+-Infinity</code></li>
<li>小数位大于 0，表示 <code>NaN</code></li>
</ul>
</li>
</ul>
<h3 id="小数位（fraction）"><a href="#小数位（fraction）" class="headerlink" title="小数位（fraction）"></a>小数位（fraction）</h3><p>小数位共有 52 位，由于二进制科学计数法的小数部分总是 1.xxx，所以第1位就被省略了，52位全部用来表示小数点后面的部分。</p>
<h2 id="二、数字-1-是如何存储的？"><a href="#二、数字-1-是如何存储的？" class="headerlink" title="二、数字 1 是如何存储的？"></a>二、数字 1 是如何存储的？</h2><p>了解了存储方式后，我们先来看看一个最简单的数值（十进制数字 1）是如何存储的。</p>
<p>对于十进制数字 1，用科学计数法可以表示为 <code>1.0 * 10e0</code>，转换成二进制科学计数法就是 <code>1.0 * 2e0</code>。可以很明显的看出：</p>
<ul>
<li>因为是正数，符号位是 0；</li>
<li>指数位也是 0，偏移后就是1023，也就是二进制 01111111111</li>
<li>小数位全是 0</li>
</ul>
<p>所以整体表示为：</p>
<p>0</p>
<p>01111111111</p>
<p>0000000000000000000000000000000000000000000000000000</p>
<p>（蓝色是符号位，绿色是指数位，红色是小数位）</p>
<h2 id="三、为什么能够精确表示的整数范围是-9007199254740991-9007199254740991？"><a href="#三、为什么能够精确表示的整数范围是-9007199254740991-9007199254740991？" class="headerlink" title="三、为什么能够精确表示的整数范围是 -9007199254740991~9007199254740991？"></a>三、为什么能够精确表示的整数范围是 <code>-9007199254740991~9007199254740991</code>？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Number.MAX_SAFE_INTEGER</span><br><span class="line">&gt; // 9007199254740991</span><br><span class="line">&gt; Number.MIN_SAFE_INTEGER</span><br><span class="line">&gt; // -9007199254740991</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什能够精确表示的整数范围是 <code>-9007199254740991~9007199254740991（-2e53+1~2e53-1）</code>呢？</p>
<p>或者问 JavaScript 中的最大安全整数，也就是 <code>Number.MAX_SAFE_INTEGER</code> 与 <code>Number.MIN_SAFE_INTEGER</code> 的值，为什么分别是 <code>-2e53+1</code> 和 <code>2e53-1</code> 呢？</p>
<p>先来理解一下安全整数的概念，所谓安全整数，指的是对于一个数值 n，n 和 n+1 都是精确的。</p>
<p>先举一个不精确的例子—— <code>2e53</code>，然后会发现 <code>2e53</code> 和 <code>2e53+1</code> 居然是相等的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(2, 53)</span><br><span class="line">&gt; // 9007199254740992</span><br><span class="line">&gt; Math.pow(2, 53) + 1</span><br><span class="line">&gt; // 9007199254740992</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>所以 <code>2e53</code> 不是一个安全整数。</p>
<p>我们先来看下 <code>2e53-1</code> 的表示是 <code>1.11111……（小数点后 52 个 1） * 2e52</code>，加 1 后变成 <code>1.00000……（小数点后 52 个0）* 2e53</code>，这个时候再加 1 呢？只要把小数点后第 53 位的 0 变成 1 即可，即 <code>1.00000……1（小数点后 52 个0，1 个 1） * 2e53</code>是 <code>2e53+1</code>，但是实际小数位一共只有 52 位，第 53 位会被截掉，截掉后小数点后面还是 52 个 0，所以 <code>2e53</code> 和 <code>2e53+1</code> 是相等的。但如果是 <code>2e53+2</code>，我们发现第 52 位变成 1 即可，即 <code>1.00000……1（小数点后51个0，1个1） * 2e53</code>，所以 <code>2e53+2</code> 又是正常的。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>2e53-2</td>
<td>9007199254740990</td>
</tr>
<tr>
<td>2e53-1</td>
<td>9007199254740991</td>
</tr>
<tr>
<td>2e53</td>
<td>9007199254740992</td>
</tr>
<tr>
<td>2e53+1</td>
<td>9007199254740992</td>
</tr>
<tr>
<td>2e53+2</td>
<td>9007199254740994</td>
</tr>
</tbody>
</table>
<p>所以这个问题可以理解为，小数位数（有效数字）必须大于指数值，才能精准表示整数。</p>
<p>比如对于十进制的科学计数法，假设只能有两位有效数字，那么最大安全数就是 <code>9.99 * 10e2</code>，即 <code>10e3-1</code>，对于 <code>1000（1.00 * 10e3）</code>以后的整数，只有表示 <code>1.01 * 10e3（1010）</code>、<code>1.02 * 10e3（1020）</code>等是准确的，中间的 1011、1012 都无法被准确表示。</p>
<p>所以对于二进制表示的 JavaScript 整数来说，当指数大于或等于 53 时，52 个小数位就不能再精准的表示了，所以 JavaScript 中最大的安全整数是 <code>2e53-1</code>。最小的安全整数也一样，是 <code>-(2e53-1)</code>，即 <code>-2e53+1</code>。</p>
<h2 id="四、为什么能够表示的最大数值范围是-5e-324-1-7976931348623157e-308？"><a href="#四、为什么能够表示的最大数值范围是-5e-324-1-7976931348623157e-308？" class="headerlink" title="四、为什么能够表示的最大数值范围是 5e-324~1.7976931348623157e+308？"></a>四、为什么能够表示的最大数值范围是 <code>5e-324~1.7976931348623157e+308</code>？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Number.MAX_VALUE</span><br><span class="line">&gt; // 1.7976931348623157e+308</span><br><span class="line">&gt; Number.MIN_VALUE</span><br><span class="line">&gt; // 5e-324</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>首先明确一点，这两个数值都是大于 0 的，一个是最接近 <code>Infinity</code> 的数值，一个是最接近 <code>0</code> 的数值，为什么是这两个值呢？这个问题比较好回答一些，了解到 JavaScript 数值的存储方式后，只需按最大最小计算一下就可以了。</p>
<p>对于最大数值：<br>除去边界值，指数位最大是 1023。而小数位最大就是 52 位全部是 1，二进制表示为 1.11111……（小数点后52个1，这个值转成十进制是 <code>1.9999999999999998</code>），所以 JavaScript 可以表示的最大数是</p>
<p>1.1111111111111111111111111111111111111111111111111111 * 2e1023</p>
<p>算出来就是 <code>1.7976931348623157e+308</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1.9999999999999998 * Math.pow(2, 1023)</span><br><span class="line">&gt; // 1.7976931348623157e+308</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>对于最小数值：<br>除去边界值，指数位最小是 -1022。而小数位最小就是 52 位中的前 51 位全部是 0，最后一位是 1，二进制表示为1.000……1（中间 51 个 0，转成十进制是 <code>2.220446049250313e-16</code>），所以 JavaScript 可以表示的最小数是</p>
<p>1.0000000000000000000000000000000000000000000000000001 * 2e1023</p>
<p>算出来就是 <code>5e-324</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2.220446049250313e-16 * Math.pow(2, -1022)</span><br><span class="line">&gt; // 5e-324</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h2 id="五、为什么-0-1-0-2-不等于-0-3？"><a href="#五、为什么-0-1-0-2-不等于-0-3？" class="headerlink" title="五、为什么 0.1+0.2 不等于 0.3？"></a>五、为什么 0.1+0.2 不等于 0.3？</h2><p>好了。现在对于 JavaScript 数值的存储都已经了解了。现在我们来看最后一个问题：为什么 <code>0.1+0.2</code>不等于 0.3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0.1 + 0.2</span><br><span class="line">&gt; // 0.30000000000000004</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>首先我们要把 0.1 和 0.2 转换成二进制科学计数法表示，十进制小数转二进制的方法不要忘记了，就是一直<strong>乘 2 取整，直到小数点后为 0</strong>。</p>
<h3 id="转换-0-1"><a href="#转换-0-1" class="headerlink" title="转换 0.1"></a>转换 0.1</h3><table>
<thead>
<tr>
<th>计算值</th>
<th>乘2</th>
<th>取整</th>
<th>本轮计算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.1</td>
<td>0.2</td>
<td>0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.2</td>
<td>0.4</td>
<td>0</td>
<td>0.00</td>
</tr>
<tr>
<td>0.4</td>
<td>0.8</td>
<td>0</td>
<td>0.000</td>
</tr>
<tr>
<td>0.8</td>
<td>1.6</td>
<td>1</td>
<td>0.0001</td>
</tr>
<tr>
<td>0.6</td>
<td>1.2</td>
<td>1</td>
<td>0.00011</td>
</tr>
<tr>
<td>0.2</td>
<td>0.4</td>
<td>0</td>
<td>0.000110</td>
</tr>
<tr>
<td>0.4</td>
<td>0.8</td>
<td>0</td>
<td>0.0001100</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>算到这里，应该已发现了，这样乘下去，永远也不会结束。所以会得到一个循环小数，0.000110011……（0011循环）。表示成科学计数法是：</p>
<p>1.1001100110011001100110011001100110011001100110011001 10011……（0011循环） * 2e-4</p>
<p>因为小数位（红色部分）只有52位，所以我们要舍去多余的部分，根据 <strong>0 舍 1 入</strong>的规则，我们最终得到：</p>
<p>1.1001100110011001100110011001100110011001100110011010 * 2e-4</p>
<h3 id="转换-0-2"><a href="#转换-0-2" class="headerlink" title="转换 0.2"></a>转换 0.2</h3><p>对于0.2，用同样的方法计算，得到的结果是 0.00110011……（0011循环）。</p>
<p>表示成科学计数法是：</p>
<p>1.1001100110011001100110011001100110011001100110011001 10011 * 2e-3</p>
<p>舍去多余的部分，得到：</p>
<p>1.1001100110011001100110011001100110011001100110011010 * 2e-3</p>
<p>经过这一步转换发现，0.1 和 0.2 都无法精确转换成二进制科学计数法表示，所以也不能被精确存储，于是计算结果出现意外也就不奇怪了。</p>
<h3 id="计算-0-1-0-2"><a href="#计算-0-1-0-2" class="headerlink" title="计算 0.1+0.2"></a>计算 <code>0.1+0.2</code></h3><p>我们接着来计算 <code>0.1+0.2</code>，首先两个数值的指数位是不同的，我们必须把指数位统一，规则就是把指数位统一成较大的那个。于是 0.1 被转换成：</p>
<p>0.1100110011001100110011001100110011001100110011001101 0 * 2e-3</p>
<p>舍去多余的小数位：</p>
<p>0.1100110011001100110011001100110011001100110011001101 * 2e-3</p>
<p>我们把 0.1 和 0.2 的小数部分相加</p>
<p>0.1100110011001100110011001100110011001100110011001101 <em>2e-31.1001100110011001100110011001100110011001100110011010</em> 2e-3</p>
<p>结果得到：</p>
<p>10.0110011001100110011001100110011001100110011001100111 * 2e-3</p>
<p>转换成标准的科学计数法：</p>
<p>1.0011001100110011001100110011001100110011001100110011 1 * 2e-2</p>
<p>舍去多余的小数位最终得到：</p>
<p>1.0011001100110011001100110011001100110011001100110100 * 2e-2</p>
<p>很明显，<code>0.1+0.2</code> 的最终结果是一个近似值。那么 0.3 就是准确的吗？</p>
<h3 id="转换-0-3"><a href="#转换-0-3" class="headerlink" title="转换 0.3"></a>转换 0.3</h3><p>同样的，我们来计算 0.3</p>
<table>
<thead>
<tr>
<th>计算值</th>
<th>乘2</th>
<th>取整</th>
<th>本轮计算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.3</td>
<td>0.6</td>
<td>0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.6</td>
<td>1.2</td>
<td>1</td>
<td>0.01</td>
</tr>
<tr>
<td>0.2</td>
<td>0.4</td>
<td>0</td>
<td>0.010</td>
</tr>
<tr>
<td>0.4</td>
<td>0.8</td>
<td>0</td>
<td>0.0100</td>
</tr>
<tr>
<td>0.8</td>
<td>1.6</td>
<td>1</td>
<td>0.01001</td>
</tr>
<tr>
<td>0.6</td>
<td>1.2</td>
<td>1</td>
<td>0.010011</td>
</tr>
<tr>
<td>0.2</td>
<td>0.4</td>
<td>0</td>
<td>0.0100110</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>得到：</p>
<p>0.0100110011001100110011001100110011001100110011001100 110011……（0011循环）</p>
<p>转换成二进制科学计数法，并舍入多余的小数位，最终得到</p>
<p>1.0011001100110011001100110011001100110011001100110011 * 2e-2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&gt;     System.out.println(<span class="string">"代码支持的是真好"</span>)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2019/03/14/hello-world/">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 PEACE & LOVE</p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, <a href="https://github.com/jeremyfan/hexo-theme-still" target="_blank">theme</a> by <a href="https://github.com/jeremyfan" target="_blank">John Doe</a>.</p></div></footer></div></body></html>